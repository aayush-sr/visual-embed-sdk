= Development and deployment using TML and REST API
:toc: true
:toclevels: 2

:page-title: Development and deployment using TML and REST API
:page-pageid: development-and-deployment
:page-description: Development and deployment following the SDLC practices can be achieved using TML and REST API

When deploying embedded analytics, there is a set of defined practices for the development, testing, and deployment of content similar to the processes used for development of code for integration between the systems.

The ThoughtSpot system contains many types of objects that link together. These objects can broadly be split into data objects and content objects. All of the objects are modeled using the link:https://cloud-docs.thoughtspot.com/admin/ts-cloud/tml.html[ThoughtSpot modeling language (TML), window=_blank]. The TML for an object can be viewed and edited through the UI and via REST APIs. With the proper understanding of TML and how the APIs work, you can integrate ThoughtSpot into your source control system and programmatically move content through your development and deployment phases.

[NOTE]
====
This article assumes an understanding of how ThoughtSpot uses groups and sharing to control the visibility of content to different groups. See xref:multi-tenancy-best-practices.adoc[Multi-tenancy best practices] for a thorough explanation of how to control object access using ThoughtSpot groups.
====

== ThoughtSpot modeling language
Every object type in ThoughtSpot has a representation in link:https://cloud-docs.thoughtspot.com/admin/ts-cloud/tml.html[TML, window=_blank]. TML documents are available by default in the easy-to-read link:https://en.wikipedia.org/wiki/YAML[YAML, window=_blank] format, and can also be requested in JSON format from the ThoughtSpot REST API.

Almost every aspect of an object can be defined or modified via TML, with a few limitations around making updates to very complicated data modeling features. While building content in ThoughtSpot is most easily achieved via the web-based UI, TML allows for integrating into common SDLC processes, deploying changes across a whole environment, and scripting complex SaaS deployments.

=== REST API endpoints for TML
There are two REST API endpoints for working with TML, one to xref:tml-api.adoc#export[export (download)] and one to xref:tml-api#import[import (upload)]. The APIs can retrieve and upload multiple TML files at a time, which tells the system to look at name references within the set of uploaded TML files first, before looking to existing objects on the ThoughtSpot server. If you are importing TML files one at a time, you will often need to include the `fqn` property to specify between objects with the same name.

The TML import REST API call itself does not specify any objects. All details of the object to be created or modified are specified *within the uploaded TML file*, including the GUID of an object you wish to update.

==== Download object TML
If you want to store TML within Git or any other version control system, you'll use the xref:tml-api.adoc#export[export REST API endpoint] to retrieve the TML representations of the objects on the ThoughtSpot server. Alternatively, you might use the ThoughtSpot server itself as your system of record, but export TML and apply changes programmatically before importing these modified TML files as new objects.

You can pass any number of GUIDs in the `export_ids` argument, although it may be simpler to retrieve one at a time.

The `formattype` argument can be set to `YAML` or `JSON`. YAML is more human-readable and matches the view when you edit TML within the ThoughtSpot UI, while JSON may be easier to process for programmatic manipulation.

The `export_associated` argument retrieves the TML objects for all related objects when used. This feature can be used for grabbing a full set of dependencies, but it generates a more complex response that must be parsed into individual elements.

==== Create new objects
To create a new object on the server, you call the xref:tml-api#import[import REST API endpoint] with the *force_create* property set to *true*. Even if the TML document has a GUID, *force_create=true* should result in a new object on the server with a new GUID. You can also remove the `guid` property from the TML document, which guarantees that a new object will be created. The safest practice is to both remove `guid` from TML and use the *force_create=true* argument in the import call.

==== Update existing objects
To update an existing object on the ThoughtSpot server, you must find the GUID of the object to be updated, then update the TML document's *guid* property. The xref:metadata-api.adoc[metadata APIs], in particular, the  xref:metadata-api.adoc#object-header[/metadata/listobjectheaders] endpoint can be used to determine the GUID of an existing object.

==== Naming constraints and GUIDs

ThoughtSpot enforces unique names only on *connections*. Duplicate names are allowed for all other object types (tables, worksheets, Liveboards, and answers). Every object has a globally unique ID (GUID) for identifying the object without any ambiguity. Within the link:https://cloud-docs.thoughtspot.com/admin/ts-cloud/tml.html[ThoughtSpot Modeling Language (TML) specification, window=_blank], the `fqn` property is available to specify a GUID when names might be ambiguous.

You can simplify some processes by setting your own best practice rules for giving objects unique names. If your objects have unique names, you won't have to look up GUIDS via the REST API to use TML. For some multi-tenanted use cases, you will want many objects with the same display name, with access control rules determining which objects a given user sees, and then you will need to use GUIDs to differentiate those objects when uploading TML.

GUIDs are randomly generated when an object is first created. If you need to track relationships between objects and you require that objects all have the same display name, you should store the relationships between various GUIDs for later reference when you first publish the child objects. For example, if you want to know which Liveboards are copied from a particular template, store the returned GUIDs of the child versions when you first publish them, so that you can push future updates from the parent Liveboard to its descendants.

=== Data objects
Data objects represent the various components of the data model within ThoughtSpot, such as *connections*, *tables*, *joins*, *views*, and *worksheets*.

Connections and joins do not have TML representations.

==== Connections
Connections contain the details and credentials necessary to connect to a cloud data warehouse. Every table, join, view, and worksheet all are linked to a particular connection, and relationships between those objects can only exist within the scope of the connection.

Connections do not have a TML representation, but can be created and modified via the xref:connections-api.adoc[data connection REST APIs].

Connections __must have unique names__ within the entire ThoughtSpot server. Connections do have GUIDs, but __only the name is necessary in TML__ files due to this uniqueness constraint.

==== Tables
link:https://cloud-docs.thoughtspot.com/admin/ts-cloud/tml.html#syntax-tables[Table objects, window=_blank] represent an actual table (or view) within a database.

Within ThoughtSpot, the display names for tables __do not have uniqueness constraints__. You can create or import tables with the same display names.

When importing a table through the ThoughtSpot UI, a table's display name will default to the table's name in the data warehouse, but you can change the display name to whatever you'd like. You can specify the display name within the TML document when creating a table via TML import by changing the `name` property, while leaving the `db_table` property as it was originally imported.

[source,yaml]
----
guid: <table_guid>
table:
  name: <table_name>
  db: <database_name>
  schema: <schema_name>
  db_table: <database_table_name>
  connection:
    name: <connection_name>
    type: <connection_type>
 ...
----

===== Join relationships and row-level security rules

ThoughtSpot will import join relationships between tables when adding the table through the UI if the relationships are defined within the database. You can also manually define join relationships through the UI or table TML.

Joins do not have separate TML representations, but are defined in table objects in the `joins_with` section.

Row-level security (RLS) rules are defined in the `rls_rules` section of the table TML. Similar to the `joins_with` section, RLS rules must reference existing table objects for the TML to validate.

If you are in the process of uploading many different tables, you should either import all the tables in the same import REST API call, or do the following:

 1. Remove the `rls_rules` and `joins_with` sections from the TML document on the initial import of each table TML. Save the GUID of each newly created object where it can be referenced to the original GUID.
 2. Check that all table objects have been created successfully on the ThoughtSpot server.
 3. Do a second import of the TML documents with the `rls_rules` and `joins_with` sections. Specify the GUIDs of the newly created table objects on the server in the TML documents' `guid` property to update the new objects rather than the original objects.

==== Worksheets
Worksheets combine several tables into a coherent data model optimized for searches. The link:https://cloud-docs.thoughtspot.com/admin/ts-cloud/tml.html#syntax-worksheets[TML syntax for worksheets, window=_blank] defines all of the aspects of the worksheet, including the tables it joins together, the columns and their properties, filters, and so on.

For development and deployment, the `tables`, `joins` and `table_paths` sections are the most important.

The `tables` section is a list of table objects that exist on the ThoughtSpot Server. The `name` property is all that is included in an exported TML file, and this matches the `name` property of the table object. If there is more than one table object on the server with identical name properties, you must use the `fqn` property to specify the GUID of the particular table you want. However, the string value of `name` is used in the `joins` section, so the correct process for adding an `fqn` property is as follows:

1. Find the GUID of the specific table from the ThoughtSpot server.
2. Add the `fqn` element. Set the GUID as the value.
3. Copy the value from the `name` element.
4. Create an `id` property and set the value as the `name` value.
5. Remove the `name` element entirely.

So you go from
[source,yaml]
----
  tables:
  - name: <table_name_1>
----

to

[source,yaml]
----
  tables:
  - id : <table_name_1>
    fqn : <GUID_of_table_name>
----

The `name` property, which is now transformed into the `id` property, is used in the `joins` and `table_paths` sections that follow. Under `joins`, the `source` and `destination` properties take the string `id` property of a table in the tables list. In a TML file exported from ThoughtSpot, you won't have to make any changes, because this value will already be set to what was defined in the `name` property, and we've maintained that value by switching it to the `id` property.

Under `table_paths`, the `table` property also uses the values we moved to `id`. The list of join names under `join_path` will need to match the text value of the `name` element of an item in the `joins`. This should be valid as exported and not require any changes, but if you do change the `name` value of a join, you will need to update the value in the `join_path` list in `table_paths`.

[source,yaml]
----
  joins:
  - name: <join_name_1>
    source: <source_table_name>
    destination: <destination_table_name>
    type: [RIGHT_OUTER | LEFT_OUTER | INNER | OUTER]
    on: <join_expression_string>
    is_one_to_one: [ false | true ]
  - ...
  table_paths:
  - id: <table_path_name_1>
    table: <table_name_1>
    join_path:
    - join:
      - <join_name_1>
      - <join_name_n>
----

==== Views

link:https://cloud-docs.thoughtspot.com/complex-search/about-query-on-query.html[Views, window=_blank] transform a saved search into a data source, allowing for analysis that would require complex sub-queries in SQL. Views can be joined with other data objects in a worksheet. The best practice is to make views available to answers and Liveboards through a worksheet.

The link:https://cloud-docs.thoughtspot.com/admin/ts-cloud/tml.html#syntax-views[TML syntax for views, window=_blank] is similar to that of worksheets, in that it defines links to table objects on the ThoughtSpot server and join overrides using the `joins` and `table_paths` sections. What truly distinguishes a view is the `search_query` element, which contains a string using the xref:search-data-api.adoc[ThoughtSpot search syntax].

[source,yaml]
----
guid: <view_guid>
view:
  name: <view_name>
  description:
    This is a multi-line description of the View.
    Description line 2
  tables:
  - name: <table_name_1>
    id : <optional_table_id>
    fqn : <optional_GUID_of_table_name>
  - name: <table_name_2>
  - name: <table_name_n>
  joins:
  - name: <join_name_1>
    source: <source_table_name>
    destination: <destination_table_name>
    type: [RIGHT_OUTER | LEFT_OUTER | INNER | OUTER]
    on: <join_expression_string>
    is_one_to_one: [ false | true ]
  table_paths:
  - id: <table_path_name_1>
    table: <table_name_1>
    join_path:
    - join:
      - <join_name_1>
      - <join_name_n>
 ...
  search_query: <query_string>
 ...
----

=== Content objects

Content objects are *answers* (saved searches) and *Liveboards*. An answer on a Liveboard is not linked in any way to an answer outside that Liveboard. When you pin an answer to a Liveboard, the full definition of the answer is copied into the Liveboard definition at that time. However, the capabilities and definitions for answers stored separately or on a Liveboard are identical.

Best practice is to __only connect answers and Liveboards to worksheets__. Although they can connect directly to tables, it is far simpler to adjust references within the answer and Liveboard TML to worksheets than many individual tables.

==== Answers
The link:https://cloud-docs.thoughtspot.com/admin/ts-cloud/tml.html#syntax-answers[answer TML syntax, window=_blank] syntax defines all aspects of a saved search and how it is visualized. The `tables` property is used to point to ThoughtSpot *table*, *view* or *worksheet* objects, whichever the answer is connected to. As mentioned above, it is simpler to connect an answer to a single *worksheet*, so that you only have to update one reference in the `tables` section.

[source,yaml]
----
guid: <answer_guid>
answer:
  name: <answer_name>
  description:
    This is a multi-line description of the answer
    Description line 2
  tables:
  - id: <table_id>
    name: <table_name_1>
    fqn : <optional_GUID_of_table_name>
 ...
----

==== Liveboards
link:https://cloud-docs.thoughtspot.com/admin/ts-cloud/tml.html#syntax-pinboards[Liveboards, window=_blank] include many different answers and define a layout of the answer elements.

The answers elements on a Liveboard are referred to as visualizations and are defined in the `visualizations` section. The answer syntax here matches exactly as a separate answer stored on its own, with the `guid` property of an individual answer replaced by an `id` property. The `id` property is typically the word "Viz" and a number: "Viz 1", "Viz 10":

[source,yaml]
----
pinboard:
  name: <Liveboard_name>
  description:
    This is a multi-line description of the Liveboard
    Description line 2
  visualizations:
  - id: <viz_id_1>
    answer:
 ...
----

The `layout` section is an ordered list with a `size` property for each visualization tile. If a visualization is added programmatically, it needs a matching entry in the layout section to determine how it appears within the Liveboard. Adjustments to the order within the Liveboard can be made by reordering the layout list. The `visualization_id` property must match to an existing `id` value in the `visualizations` list.

[source,yaml]
----
  layout:
    tiles:
    - visualization_id: <visualization_id_1>
      size: <viz_id_1_size>
    - visualization_id: <visualization_id_2>
----

== Deployment methods

=== Change tracking / source control

In the development phase, most content creation and updates will occur within the ThoughtSpot web application. Changes can be made directly to TML files and uploaded, but ThoughtSpot's interface is designed for creating new searches and Liveboards with maximum speed and control. This presents the question of when and how to track content changes for content in the "development environment".

The xref:metadata-api.adoc#object-header[/metadata/listobjectheaders] can be used to retrieve the GUIDs for the various objects on the ThoughtSpot server. Looping through those GUIDs with the xref:tml-api.adoc#export[export TML REST API endpoint] allows for saving the current state of all objects to disk. A simple form of Git (or other source control) integration can be achieved simply by exporting all the TML files to a Git-enabled directory, with Git determining if there are any changes.

The `metadata/listobjectheaders` endpoint can be sorted by the `MODIFIED` keyword and then retrieved in batches, allowing a TML retrieval script to only retrieve objects modified since the last run date or some other reasonable time period.

=== Copy from one server to another
When moving content from one instance of ThoughtSpot to another, object names can be left exactly as they are from the first environment to the other. Changes like referencing a different *connection* can be achieved by changing the `name` property under the `connection` (value labeled `connection_name` below) within the link:https://cloud-docs.thoughtspot.com/admin/ts-cloud/tml.html#syntax-tables[table TML objects, window=_blank]:

[source,yaml]
----
table:
  name: <table_name>
  db: <database_name>
  schema: <schema_name>
  db_table: <database_table_name>
  connection:
    name: <connection_name>
 ...
----

=== Dev -> test -> prod
A standard pattern for software development lifecyle (SDLC) is moving content from a development (dev) environment to a test environment, and then eventually to production (prod) where end customers can see it.

==== Prefixes on content names as namespaces
The easiest way to avoid name collisions is by adding `dev_` or `test_` before the name of any object. By using a consistent __namespace prefix__, deployment scripts can easily find and replace when moving from __dev__ to __test__, or remove the prefix entirely when copying the content to prod where end customers can see it.

Example pattern:

[width="100%" cols="3,3,3"]
[options='header']
|===
|dev name|test name|prod name
|dev_Connection A|test_Connection A|Connection A
|dev_Table A|test_Table A|Table A
|===

Using this namespace prefix scheme, you can export the TML files related to "dev_Connection A" and simply update any name references by replacing "dev_" with "test_". Moving from test to prod, you remove the prefix from the names entirely.

==== Access control
Dev and test content should be xref:multi-tenancy-best-practices.adoc[shared only to specific groups] designed to give access to the correct app developer users. Individual tenant users will never see content that is not shared with them.

=== Single-tenant databases deployment model
As described in the multi-tenancy best practices article, the single-tenant databases model requires separate connections for each tenant, along with replicas of all other standardized objects. In this model, there is one additional tier of deployment: dev, test, prod template, and prod tenant content.

Prod template content is the finalized data model and other content for a given prod release, before being published out to each tenant with the necessary changes to their tenant connection.

==== Namespacing in the single-tenant databases model
When you have a different database for each of your tenants, you'll programmatically build a connection for each tenant, and then copy your prod template for each tenant. In this pattern, you namespace dev, test, and prod template content, and remove the namespace for the tenant-specific content.

Example pattern:

[width="100%" cols="3,3,3,3"]
[options='header']
|===
|dev name|test name|prod name|tenant name (per tenant)
|dev_Connection A|test_Connection A|prod_Connection A|Connection A
|dev_Table A|test_Table A|prod_Table A|Table A
|===

Each prod tenant copy will have the same name so that each tenant will not see their customer name / ID listed out. Access control through sharing will ensure they never have any awareness of the other objects that exist with the same name for the other tenants.

== Additional Resources
The link:https://github.com/thoughtspot/ts_rest_api_and_tml_tools[ts_rest_api_and_tml_tools project, window=_blank] provides a `tml.py` module with Python objects that model the TML objects and the actions described within. This library is intended as a working example and guide and is not maintained or supported by ThoughtSpot.

Within the examples directory, the link:https://github.com/thoughtspot/ts_rest_api_and_tml_tools/blob/main/examples/tml_changes_monitor.py[tml_changes_monitor.py, window=_blank] script is a simple example of exporting all TML objects to disk for use with Git or another source control system. The link:https://github.com/thoughtspot/ts_rest_api_and_tml_tools/blob/main/examples/tml_create_new_from_existing.py[tml_create_new_from_existing.py, window=_blank] script combines REST API commands with the TML changes necessary to copy content from one connection to another.
